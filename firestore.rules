/**
 * @file AgriClear Firestore Security Rules
 * @version Prototyping Mode - Data shape is not strictly enforced. Authorization is strictly enforced.
 *
 * @core_philosophy This ruleset enforces a strict user-ownership model for user-related data and uses denormalization to maintain authorization independence. Public read access is allowed for product listings, while write access is restricted to authorized farmers. Admin privileges are granted based on the existence of a document in the `/roles_admin` collection.
 *
 * @data_structure
 *   - `/users/{userId}`: Stores user profiles.
 *   - `/users/{userId}/farmerProfile`: Stores farmer profiles associated with users.
 *   - `/users/{userId}/buyer`: Stores buyer profiles associated with users.
 *   - `/users/{userId}/logisticsProvider`: Stores logistics provider profiles associated with users.
 *   - `/users/{userId}/admin`: Stores admin profiles associated with users.
 *   - `/productListings/{productListingId}`: Stores product listings with denormalized `farmerId` for authorization.
 *   - `/orders/{orderId}`: Stores orders with denormalized `buyerId` and `productId` for authorization.
 *   - `/shipments/{shipmentId}`: Stores shipment information.
 *   - `/escrowTransactions/{escrowTransactionId}`: Stores escrow transaction details.
 *   - `/fraudAlerts/{fraudAlertId}`: Stores fraud alert information.
 *   - `/sustainabilityRewards/{sustainabilityRewardId}`: Stores sustainability reward information.
 *   - `/roles_admin/{userId}`: Stores admin role assignments. The existence of a document grants admin privileges.
 *
 * @key_security_decisions
 *   - User data is strictly controlled by the owning user.
 *   - Product listings are publicly readable but writable only by the associated farmer.
 *   - Admin privileges are determined by the existence of a document in `/roles_admin/{userId}`.
 *   - Listing of documents in user-owned subcollections is allowed for the owning user.
 *   - No user listing is generally allowed, except for specific admin collections.
 *
 * @denormalization_for_authorization
 *   - `ProductListing` documents include a `farmerId` field to allow authorization without needing to fetch the FarmerProfile.
 *   - `Order` documents include `buyerId` and `productId` for authorization independence.
 *
 * @structural_segregation User-specific data is stored under `/users/{userId}`, providing path-based ownership and simplifying security rules. Product listings are in a separate `/productListings` collection, allowing for public read access while restricting write access to authorized farmers.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is made by a signed-in user.
     * @return {bool} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user is the owner of the resource.
     * @param {string} userId The user ID to compare against the authenticated user's ID.
     * @return {bool} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

        /**
         * @description Checks if the authenticated user is the existing owner of the resource.
         * @param {string} userId The user ID to compare against the authenticated user's ID.
         * @return {bool} True if the user is the owner and the resource exists, false otherwise.
         */
        function isExistingOwner(userId) {
            return isOwner(userId) && resource != null;
        }

    /**
     * @description Checks if the user has admin privileges based on the existence of a document in /roles_admin/{userId}.
     * @return {bool} True if the user is an admin, false otherwise.
     */
    function isAdmin() {
      return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * @description Rules for the /users/{userId} collection.
     * @path /users/{userId}
     * @allow (create) Signed-in user creates their own profile.
     * @allow (get, list) Signed-in user gets their own profile.
     * @deny (create) Signed-in user tries to create a profile for another user.
     * @deny (update, delete) Signed-in user tries to update or delete another user's profile.
     * @principle Enforces document ownership for user profiles.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // Prevent listing all users
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for the /users/{userId}/farmerProfile subcollection.
     * @path /users/{userId}/farmerProfile
     * @allow (create) Signed-in user creates their own farmer profile.
     * @allow (get, list) Signed-in user gets their own farmer profile.
     * @deny (create) Signed-in user tries to create a farmer profile for another user.
     * @deny (update, delete) Signed-in user tries to update or delete another user's farmer profile.
     * @principle Enforces document ownership for farmer profiles.
     */
    match /users/{userId}/farmerProfile {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for the /productListings/{productListingId} collection.
     * @path /productListings/{productListingId}
     * @allow (get, list) Anyone can read product listings.
     * @allow (create) Signed-in user creates a product listing with their farmerId.
     * @deny (create) Signed-in user tries to create a product listing with another user's farmerId.
     * @deny (update, delete) Signed-in user tries to update or delete a product listing they don't own.
     * @principle Allows public read access, enforces ownership for writes.
     */
    match /productListings/{productListingId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.farmerId != null; // farmerId should be present
      allow update: if isSignedIn() && resource.data.farmerId == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.farmerId == request.auth.uid && resource != null;
    }

    /**
     * @description Rules for the /users/{userId}/buyer subcollection.
     * @path /users/{userId}/buyer
     * @allow (create) Signed-in user creates their own buyer profile.
     * @allow (get, list) Signed-in user gets their own buyer profile.
     * @deny (create) Signed-in user tries to create a buyer profile for another user.
     * @deny (update, delete) Signed-in user tries to update or delete another user's buyer profile.
     * @principle Enforces document ownership for buyer profiles.
     */
    match /users/{userId}/buyer {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for the /orders/{orderId} collection.
     * @path /orders/{orderId}
     * @allow (get, list) Anyone can read orders.
     * @allow (create) Signed-in user creates an order.
     * @deny (update, delete) Signed-in user tries to update or delete an order they don't own.
     * @principle Allows public read access, but write access should be restricted based on the application logic.
     */
    match /orders/{orderId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Rules for the /users/{userId}/logisticsProvider subcollection.
     * @path /users/{userId}/logisticsProvider
     * @allow (create) Signed-in user creates their own logistics provider profile.
     * @allow (get, list) Signed-in user gets their own logistics provider profile.
     * @deny (create) Signed-in user tries to create a logistics provider profile for another user.
     * @deny (update, delete) Signed-in user tries to update or delete another user's logistics provider profile.
     * @principle Enforces document ownership for logistics provider profiles.
     */
    match /users/{userId}/logisticsProvider {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for the /shipments/{shipmentId} collection.
     * @path /shipments/{shipmentId}
     * @allow (get, list) Anyone can read shipments.
     * @allow (create) Signed-in user creates a shipment.
     * @deny (update, delete) Signed-in user tries to update or delete a shipment they don't own.
     */
    match /shipments/{shipmentId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Rules for the /users/{userId}/admin subcollection.
     * @path /users/{userId}/admin
     * @allow (create) Signed-in user creates their own admin profile.
     * @allow (get, list) Signed-in user gets their own admin profile.
     * @deny (create) Signed-in user tries to create an admin profile for another user.
     * @deny (update, delete) Signed-in user tries to update or delete another user's admin profile.
     * @principle Enforces document ownership for admin profiles.
     */
    match /users/{userId}/admin {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for the /escrowTransactions/{escrowTransactionId} collection.
     * @path /escrowTransactions/{escrowTransactionId}
     * @allow (get, list) Anyone can read escrow transactions.
     * @allow (create) Signed-in user creates an escrow transaction.
     * @deny (update, delete) Signed-in user tries to update or delete an escrow transaction they don't own.
     */
    match /escrowTransactions/{escrowTransactionId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Rules for the /fraudAlerts/{fraudAlertId} collection.
     * @path /fraudAlerts/{fraudAlertId}
     * @allow (get, list) Anyone can read fraud alerts.
     * @allow (create) Signed-in user creates a fraud alert.
     * @deny (update, delete) Signed-in user tries to update or delete a fraud alert they don't own.
     */
    match /fraudAlerts/{fraudAlertId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Rules for the /sustainabilityRewards/{sustainabilityRewardId} collection.
     * @path /sustainabilityRewards/{sustainabilityRewardId}
     * @allow (get, list) Anyone can read sustainability rewards.
     * @allow (create) Signed-in user creates a sustainability reward.
     * @deny (update, delete) Signed-in user tries to update or delete a sustainability reward they don't own.
     */
    match /sustainabilityRewards/{sustainabilityRewardId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }
    /**
     * @description Rules for the /roles_admin/{userId} collection. The existence of a document grants admin privileges.
     * @path /roles_admin/{userId}
     * @allow (create) Only admins can grant admin roles.
     * @allow (get, list) Only admins can list admin roles.
     * @deny (create) Non-admins cannot create admin roles.
     * @deny (update, delete) Only admins can update or delete admin roles.
     * @principle Uses "Existence over Content" for admin privileges.
     */
    match /roles_admin/{userId} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if isAdmin();
      allow update: if false;
      allow delete: if isAdmin();
    }
  }
}